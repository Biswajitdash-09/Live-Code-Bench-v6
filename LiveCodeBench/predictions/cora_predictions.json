[
  {
    "question_id": "1873_A",
    "code_list": [
      "def solve():\n    t = int(input())\n    for _ in range(t):\n        s = input().strip()\n        target = \"abc\"\n        \n        # Count positions where characters don't match\n        mismatches = []\n        for i in range(3):\n            if s[i] != target[i]:\n                mismatches.append(i)\n        \n        # If 0 mismatches: already \"abc\" - YES\n        # If 2 mismatches: can swap to fix - YES\n        # If 1 or 3 mismatches: cannot fix with at most one swap - NO\n        if len(mismatches) == 0 or len(mismatches) == 2:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    solve()"
    ]
  },
  {
    "question_id": "1873_B",
    "code_list": [
      "def solve():\n    import sys\n    input_data = sys.stdin.read().split()\n    idx = 0\n    \n    t = int(input_data[idx])\n    idx += 1\n    \n    for _ in range(t):\n        n = int(input_data[idx])\n        idx += 1\n        a = list(map(int, input_data[idx:idx+n]))\n        idx += n\n        \n        # Find the index of the minimum element\n        min_idx = 0\n        for i in range(1, n):\n            if a[i] < a[min_idx]:\n                min_idx = i\n        \n        # Add 1 to the minimum digit to maximize the product\n        a[min_idx] += 1\n        \n        # Calculate the product\n        product = 1\n        for num in a:\n            product *= num\n        \n        print(product)\n\nsolve()"
    ]
  },
  {
    "question_id": "1873_D",
    "code_list": [
      "import sys\n\ndef solve():\n    data = sys.stdin.read().split('\\n')\n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    results = []\n    \n    for _ in range(t):\n        n, k = map(int, data[idx].split())\n        idx += 1\n        s = data[idx]\n        idx += 1\n        \n        count = 0\n        i = 0\n        while i < n:\n            if s[i] == 'B':\n                count += 1\n                i += k  # Skip k cells since we just made them white\n            else:\n                i += 1\n        \n        results.append(str(count))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()"
    ]
  },
  {
    "question_id": "1883_B",
    "code_list": [
      "import sys\n\ndef solve():\n    data = sys.stdin.read().split()\n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[idx])\n        k = int(data[idx + 1])\n        s = data[idx + 2]\n        idx += 3\n        \n        # Count character frequencies\n        freq = {}\n        for c in s:\n            freq[c] = freq.get(c, 0) + 1\n        \n        # Count characters with odd frequency\n        odd_count = sum(1 for v in freq.values() if v % 2 == 1)\n        \n        remaining_length = n - k\n        \n        if remaining_length % 2 == 0:\n            # Need 0 odd characters after removal\n            # To get 0 odd: remove 1 from each odd char (cost = odd_count),\n            # then remove pairs from any even chars\n            if k >= odd_count and (k - odd_count) % 2 == 0:\n                results.append(\"YES\")\n            else:\n                results.append(\"NO\")\n        else:\n            # Need exactly 1 odd character after removal\n            # We can achieve exactly 1 odd if:\n            # - odd_count == 1 and k is even (remove from even groups only)\n            # - odd_count > 1 and (k - odd_count) is even (remove 1 from all odd, then pairs)\n            if odd_count == 1:\n                if k % 2 == 0:\n                    results.append(\"YES\")\n                else:\n                    results.append(\"NO\")\n            else:\n                if k >= odd_count and (k - odd_count) % 2 == 0:\n                    results.append(\"YES\")\n                else:\n                    results.append(\"NO\")\n    \n    print(\"\\n\".join(results))\n\nsolve()"
    ]
  },
  {
    "question_id": "1883_C",
    "code_list": [
      "import sys\n\ndef solve():\n    data = sys.stdin.read().split()\n    idx = 0\n    \n    # Read number of test cases (should be 15 based on input)\n    # But first line is actually \"15\", so let's parse\n    \n    t = 15  # Based on the input structure\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[idx])\n        k = int(data[idx + 1])\n        idx += 2\n        \n        arr = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        if k == 2:\n            # Need at least one even number\n            min_ops = float('inf')\n            for a in arr:\n                if a % 2 == 0:\n                    min_ops = 0\n                    break\n            if min_ops != 0:\n                min_ops = 1  # Make any odd number even\n        \n        elif k == 3:\n            # Need at least one number divisible by 3\n            min_ops = float('inf')\n            for a in arr:\n                needed = (3 - a % 3) % 3\n                min_ops = min(min_ops, needed)\n        \n        elif k == 4:\n            # For product to be divisible by 4, we need:\n            # 1. At least one number divisible by 4\n            # 2. Or at least 2 even numbers\n            \n            # Option 1: Make a number divisible by 4\n            min_ops_4 = float('inf')\n            for a in arr:\n                needed = (4 - a % 4) % 4\n                min_ops_4 = min(min_ops_4, needed)\n            \n            # Option 2: Make at least 2 numbers even\n            ops_needed = []\n            for a in arr:\n                if a % 2 == 0:\n                    ops_needed.append(0)\n                else:\n                    ops_needed.append(1)\n            \n            ops_needed.sort()\n            if len(ops_needed) >= 2:\n                min_ops_2_even = ops_needed[0] + ops_needed[1]\n            else:\n                min_ops_2_even = float('inf')\n            \n            min_ops = min(min_ops_4, min_ops_2_even)\n        \n        elif k == 5:\n            # Need at least one number divisible by 5\n            min_ops = float('inf')\n            for a in arr:\n                needed = (5 - a % 5) % 5\n                min_ops = min(min_ops, needed)\n        \n        results.append(min_ops)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()"
    ]
  },
  {
    "question_id": "1899_A",
    "code_list": [
      "import sys\n\ndef solve():\n    data = sys.stdin.read().split()\n    idx = 0\n    \n    t = int(data[idx])\n    idx += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        \n        # Vanya can always win within 3 turns:\n        # If n % 3 == 0: After Vanya's first move, the number is n\u00c2\u00b11 \u00e2\u2030\u00a1 \u00c2\u00b11 (mod 3)\n        #                Then Vova moves to one of the two adjacent values\n        #                On Vanya's second move (move 3), he can reach a multiple of 3\n        # If n % 3 == 1: Vanya subtracts 1 to reach a multiple of 3 on move 1\n        # If n % 3 == 2: Vanya adds 1 to reach a multiple of 3 on move 1\n        results.append(\"First\")\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()"
    ]
  },
  {
    "question_id": "1899_B",
    "code_list": [
      "import sys\n\ndef solve():\n    input = sys.stdin.read().split()\n    idx = 0\n    t = int(input[idx])\n    idx += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(input[idx])\n        idx += 1\n        a = list(map(int, input[idx:idx+n]))\n        idx += n\n        \n        # Compute prefix sums\n        prefix = [0] * (n + 1)\n        for i in range(n):\n            prefix[i+1] = prefix[i] + a[i]\n        \n        max_diff = 0\n        \n        # For each k from 1 to n\n        for k in range(1, n + 1):\n            if n % k != 0:\n                continue\n            \n            # Calculate sum for each truck\n            num_trucks = n // k\n            truck_sums = []\n            \n            for truck in range(num_trucks):\n                start = truck * k\n                end = start + k\n                truck_sum = prefix[end] - prefix[start]\n                truck_sums.append(truck_sum)\n            \n            # Max absolute difference for this k\n            current_diff = max(truck_sums) - min(truck_sums)\n            max_diff = max(max_diff, current_diff)\n        \n        results.append(max_diff)\n    \n    print('\\n'.join(map(str, results)))\n\nsolve()"
    ]
  },
  {
    "question_id": "1899_C",
    "code_list": [
      "import sys\n\ndef solve():\n    data = sys.stdin.read().split()\n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    \n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        a = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        # Initialize by starting with just the first element\n        max_sum = a[0]\n        current_sum = a[0]\n        \n        for i in range(1, n):\n            # If adjacent elements have the same parity, we cannot extend\n            # the current subarray. We must start fresh from the current element.\n            if (a[i] % 2) == (a[i-1] % 2):\n                current_sum = a[i]\n            else:\n                # Different parity - we can append this element to the valid subarray\n                current_sum = current_sum + a[i]\n            \n            max_sum = max(max_sum, current_sum)\n        \n        print(max_sum)\n\nif __name__ == \"__main__\":\n    solve()"
    ]
  },
  {
    "question_id": "1899_D",
    "code_list": [
      "import sys\n\ndef solve():\n    data = sys.stdin.read().split()\n    idx = 0\n    t = int(data[idx])\n    idx += 1\n    \n    for _ in range(t):\n        n = int(data[idx])\n        idx += 1\n        a = list(map(int, data[idx:idx + n]))\n        idx += n\n        \n        # Initialize by starting with just the first element\n        max_sum = a[0]\n        current_sum = a[0]\n        \n        for i in range(1, n):\n            # If adjacent elements have the same parity, we cannot extend\n            # the current subarray. We must start fresh from the current element.\n            if (a[i] % 2) == (a[i-1] % 2):\n                current_sum = a[i]\n            else:\n                # Different parity - we can append this element to the valid subarray\n                current_sum = current_sum + a[i]\n            \n            max_sum = max(max_sum, current_sum)\n        \n        print(max_sum)\n\nif __name__ == \"__main__\":\n    solve()"
    ]
  }
]